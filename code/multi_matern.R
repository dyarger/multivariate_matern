
source('/Users/drewyarger/multi_matern_source.R')
A <- matrix(nrow = 2, ncol = 2,
            complex(real = rnorm(4), 
                    imaginary = rnorm(4)))
# A <- matrix(nrow = 2, ncol = 2,
#             complex(real = c(1,0,0,1)))
# A <- matrix(nrow = 2, ncol = 2,
#             complex(real = c(1,0,0,1)))
# A <- matrix(nrow = 2, ncol = 2,
#             complex(real = c(1.1,1,1,1),
#                     imaginary = c(.4,.2, .1, 0)))
A <- matrix(nrow = 2, ncol = 2,
            complex(real = c(-1,1,1,0),
                    imaginary = c(1,2,-1,1)))
(A %*% t(Conj(A)))
AA_star <- A %*% t(Conj(A))
# AA_star <- matrix(nrow = 2, ncol = 2,
#                   complex(real = c(1,0,0,1),
#                           imaginary = c(0, 10000, 10000,0)))
nu <- 2

#### Plot covariance
# note - plot does not show reversability for nu = 1/2, 3/2, ...
plot_cov(AA_star = AA_star, nu = nu)

#### Simulate in 1 dimension of time ###
# t_eval - points to evaluate
# N - number of basis function approximation
N <- 1000
data <- sim_bivariate(AA_star = AA_star, nu = nu, t_eval = seq(-5, 5, by = .01),
                      N = N)
par(mfrow = c(2,1))
plot(data[,1], data[,2], type = 'l', main = 'Simulation, Variable 1')
plot(data[,1], data[,3], type = 'l', main = 'Simulation, Variable 2')

#### Compare with matern generated by RandomFields package - limited to non-reversible
library(RandomFields)
x <- seq(-5,5, by =.01)
sigmaone <- cross_cov(0, 0, nu = nu, z_ij = AA_star[1,1])
sigmatwo <- cross_cov(0, 0, nu = nu, z_ij = AA_star[2,2])
rho <- cross_cov(0, 0, nu = nu, z_ij = AA_star[1,2])/ sqrt(sigmaone * sigmatwo)
model <- RMbiwm(nu = c(nu,nu,nu), cdiag = Re(c(sigmaone, sigmatwo)), 
                rhored  = Re(rho))# consider only non-reversible part
z <- as.data.frame(RFsimulate(model=model, x))
plot(x,z[,1], type = 'l')
plot(x,z[,2], type = 'l')

#### Turning bands method for multiple dimensions in space
n_d <- 30 # number of directions
directions <- runif(n_d, 0, pi)
directions <- seq(from = 0, to = pi,length.out =  n_d)
vec_dir <- as.matrix(cbind(cos(directions), sin(directions)))
plot(vec_dir, main = 'Directions for Turning Band method')

t_eval <- as.matrix(expand.grid(seq(-5, 5, length.out = 125),seq(-5, 5, length.out = 125)))
data <- list()
N <- 400
for (r in 1:n_d) {
  data[[r]] <- directions[r]^20* sim_bivariate(AA_star = AA_star, nu = nu, t_eval = t_eval %*% vec_dir[r,],
                           N = N)
}
field1 <- apply(sapply(data, function(x) {return(x[,2])}),1, sum)/sqrt(n_d)
field2 <- apply(sapply(data, function(x) {return(x[,3])}),1, sum)/sqrt(n_d)
library(fields)
par(mfrow = c(2,1))
image.plot(matrix(field1, nrow =sqrt(nrow(t_eval))), axes=F)
image.plot(matrix(field2, nrow =sqrt(nrow(t_eval))), axes=F)


# profvis::profvis({t_eval <- as.matrix(expand.grid(seq(-5, 5, length.out = 250),seq(-5, 5, length.out = 250)))
# data <- list()
# N <- 100
# for (r in 1:n_d) {
#   data[[r]] <- sim_bivariate(AA_star = AA_star, nu = nu, t_eval = t_eval %*% vec_dir[r,],
#                              N = N)
# }})
